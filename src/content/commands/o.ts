import type { Command } from '../../interfaces/command'

export const orchestrate: Command = {
  name: 'o',
  description: 'Enter orchestrate mode for feature development',
  trigger: '/o',
  instruction:
    '# /o Command\n\nEnter orchestrate mode. Claude becomes an engineering manager, delegating to specialized agents for systematic feature development.\n\n## Overview\n\nOrchestrate mode transforms Claude from a single executor into an engineering manager that:\n- Plans and breaks down complex tasks\n- Delegates to specialized agents (Researcher, Architect, Executor, Verifier)\n- Tracks progress through session-based workflow\n- Maintains context across multiple work sessions\n\n## Commands\n\n| Command | Action |\n|---------|--------|\n| `/o` | Start new session or resume existing |\n| `/o status` | Show current session state |\n| `/o proceed` | Execute next task |\n| `/o verify` | Quality check on completed work |\n| `/o list` | List all sessions |\n| `/o cleanup` | Archive completed sessions |\n| `/o end` | End current session |\n\n## Workflow\n\n### 1. Start Session\nUse `/o` to begin. Describe your task or requirement:\n```\n/o Build a user authentication API with JWT tokens\n```\n\nThe system will:\n- Break down the task into atomic steps\n- Assign appropriate agents based on task size\n- Begin with Researcher to explore codebase\n\n### 2. Task Execution\nThe orchestrator cycles through agents:\n\n| Phase | Agent | Purpose |\n|-------|-------|---------|\n| Research | Researcher | Explore codebase, find patterns, understand structure |\n| Design | Architect | Design solution for large tasks |\n| Implement | Executor | Write code, refactor, tests |\n| Review | Verifier | Quality checks, code review |\n\n### 3. Task Sizes\n\nTasks are classified by complexity:\n\n| Size | Description | Example | Requires Architect | Requires Verify |\n|------|-------------|---------|-------------------|-----------------|\n| `[S]` | Simple, single file | Typo fix, config change | No | No |\n| `[M]` | Moderate, single feature | Feature implementation, bug fix | No | Yes |\n| `[L]` | Large, multi-file | Architectural changes, refactors | Yes | Yes |\n\n### 4. Model Selection\n\nModels are automatically selected based on task complexity:\n\n| Task Size | Researcher | Architect | Executor | Verifier |\n|-----------|------------|-----------|----------|----------|\n| `[S]` | haiku | - | haiku | - |\n| `[M]` | sonnet | - | sonnet | sonnet |\n| `[L]` | sonnet | sonnet | opus | opus |\n\n## Session Management\n\n### Starting\n- `/o`: Start fresh session with description\n- `/o` (with active session): Resume where left off\n\n### Checking Status\n`/o status` displays:\n- Current session ID\n- Task queue with progress\n- Completed tasks\n- Blockers or notes\n\n### Proceeding\n`/o proceed` executes the next task in queue:\n- Delegates to appropriate agent\n- Captures results and context\n- Updates task status\n\n### Verification\n`/o verify` runs quality checks:\n- LSP diagnostics review\n- Build verification\n- Test execution (if applicable)\n- Code review by Verifier agent\n\n### Listing Sessions\n`/o list` shows all sessions:\n- Active sessions with progress\n- Completed sessions\n- Session timestamps and summaries\n\n### Cleanup\n`/o cleanup` archives completed sessions:\n- Moves finished sessions to history\n- Frees resources\n- Keeps metadata for reference\n\n### Ending\n`/o end` closes current session:\n- Final state save\n- Summary generation\n- Returns to normal mode\n\n## Examples\n\n### Simple Task\n```\n/o Add error handling to the API gateway\n→ Classified as [M], delegated to Executor\n```\n\n### Complex Task\n```\n/o Migrate from REST to GraphQL\n→ Classified as [L], Research → Architect → Executor → Verify cycle\n```\n\n### Resume Work\n```\n/o status          # Check where we left off\n/o proceed         # Continue with next task\n```\n\n## Best Practices\n\n1. **Start with clear requirements**: The better you describe the task, the better the decomposition\n2. **Use verification**: Always run `/o verify` before considering work complete\n3. **Check status**: Use `/o status` to understand current state\n4. **End sessions**: Properly end sessions to save context for future work\n\n## Integration\n\nOrchestrate mode integrates with:\n- **Skills**: Domain knowledge from skills (typescript, golang, kubernetes, etc.)\n- **Agents**: Specialized agents for each phase\n- **Tools**: Full access to development tools (git, build, test)\n',
}
